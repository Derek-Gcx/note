# 并行计算的算法基础
[TOC]
---
## 并行算法基础
### Case Study
#### 计算前缀和
+ 问题定义
  + $n$个元素$\{x_1, x_2, ...,x_n\}$，前缀和是$n$个部分和$S_i=x_1*x_2*...*x_i, 1\leq i\leq n$
  + 串行算法
    + $S_i=S_{i-1}*x_i$，计算时间为$O(n)$
  + 并行计算  
    ![](img/2020-10-23-14-40-06.png)

### 并行算法的复杂性度量
+ 串行算法的复杂性度量
  + 最坏情况下的复杂度
  + 期望复杂度
+ 并行算法的几个复杂性度量指标
  + 运行时间$t(n)$：包含计算时间和通讯时间，分别用计算时间步和选路时间步做单位，$n$为问题实例的输入规模
  + 处理器数$p(n)$
  + 并行算法成本$c(n)=t(n)p(n)$
    + 如果一个求解问题的并行算法的成本在数量级上等于最坏情况下求解此问题所需的执行步数，则称此并行算法是成本最优的
  + 总运算量$W(n)$：并行算法求解问题时所完成的总的操作步数

### 并行算法的同步
+ 同步：同步是在时间上强使各执行进程在某一点必须互相等待
+ 可用软件、硬件和固件的办法来实现同步操作
+ 同步操作往往伴随着并行算法中的串行部分

### 并行算法的通讯
+ 通讯
  + 共享存储多处理器使用
    + global read(X, Y)和global write(X, Y)
  + 分布式存储多计算机使用
    + send(X, i)和receive(Y, j)

> 通讯示例：计算矩阵乘法结果$AX$，其中$A:n\times n, X:n\times 1$  
> ![](img/2020-10-23-15-08-59.png)

---
## 并行计算模型
### PRAM模型
#### 分类
+ PRAM-CRCW 并发读并发写
  + CPRAM-CRCW 仅允许写入相同数据
  + PPRAM-CRCW 仅允许优先级最高的处理器写入
  + APRAM-CRCW 允许任意处理器自由写入
    + 如果能定义一种关于写入优先级的良好偏序关系（比如时间顺序、得分增长等），那么就能够实现处理器的自由写入
+ PRAM-CREW 并发读互斥写
+ PRAM-EREW 互斥读互斥写

#### 计算能力比较

![](img/2020-10-23-15-17-42.png)

### 异步APRAM模型
+ 计算过程
  + 设置同步障，在同步障之前每个处理器可以执行自己各自的任务，在同步障处集中处理在之前时刻其他处理器传输的异步数据
  ![](img/2020-10-23-15-24-10.png)
+ 分析  
  ![](img/2020-10-23-15-25-53.png)

### BSP模型
![](img/2020-10-23-15-30-33.png)

### logp模型
![](img/2020-10-23-15-30-51.png)
![](img/2020-10-23-15-31-03.png)